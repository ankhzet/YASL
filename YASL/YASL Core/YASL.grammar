@start = translation-unit;

translation-unit = script-declaration external-declarations;
script-declaration = 'script'! Identifier ';'!;

external-declarations = external-declaration*;
external-declaration = declaration ';'! | function-definition;

/* ***** Declarations ***** */

/* Struct-type: declares structure.
 
 */
struct-type = struct '{'! struct-members-list '}'!;
struct = 'struct'!;
struct-members-list = struct-member (','! struct-member)* ','?;
struct-member = type-specifier declarator-list;
declarator-list = declarator (','! declarator)*;

/* Declarator: declares variable/parameter
 
 int *myInt = 10;
 int myInt;
 int myint[];
 void myFunc(int param1, param2; void *param3) {}

 int <declarator> = 10;
 int <declarator>;
 int <declarator>;

 void myFunc(int <declarator>, <declarator>; void <declarator>) {}
 void <declarator> {}

 */

declarator = pointer? direct-declarator;
direct-declarator = Identifier specific-declarator*;
pointer = '*'! pointer?;

specific-declarator = array-declarator | method-param-list-specifier;
array-declarator = '['! constant-expression? ']'!;

/* Declaration: declaration of variable, type.
 int myVar;
 typedef int myType;
 */

declaration = type-declaration | var-declaration;

/* Type-specifier: specifies type of parameter, variable, typedef-d type.
 int myVar;
 typedef int[] myType;
 void myFunc(int param1; int * param2) {}

 <type-specifier> myVar;
 typedef <type-specifier> myType;
 <type-specifier myFunc(<type-specifier> param1; <type-specifier> *param2) {}

 */
type-specifier = built-in-type | struct-type | typedef-type;
built-in-type = 'void' | 'int' | 'bool' | 'float' | 'char';

type-declaration = typedef type-specifier declarator;
typedef = 'typedef'!;
typedef-type = Identifier;

/* ***** Function definition ***** */

method-param-list-specifier = '('! method-param-list* ')'!;
method-param-list = method-param-group (';'! method-param-group)*;
method-param-group = type-specifier declarator-list;

/* ***** Var declaration ***** */

var-declaration = type-specifier init-declarator-list;

/* init-declarator: part of the statement, that initializes variables.
 int myInt = myInt2 = a * b;

 int myInt <initializer>
 */

init-declarator = declarator ('='! initializer)?;

init-declarator-list = init-declarator (','! init-declarator)*;

initializer = assignment-initializer | initializer-list;

initializer-list = '{'! initializer (','! initializer)* ','? '}'!;

assignment-initializer = assignment-expression;

/* ***** Statements ***** */

statement = expression-statement | compound-statement | jump-statement | selection-statement;

expression-statement = expression? ';'!;
compound-statement = '{'! (declaration ';'! | statement)* '}'!;

selection-statement = selection-if;// | selection-switch;
selection-if = 'if'! '('! expression ')'! statement selection-else?;
selection-else = 'else'! statement;

jump-statement = (jump-goto | jump-return | continue | break) ';'!;
jump-goto = 'goto'! Identifier;
jump-return = 'return'! expression?;
continue = 'continue'!;
break = 'break'!;


/* ***** Expressions ***** */

constant-expression = conditional-expression;

conditional-expression = ternar-expression;
ternar-expression = logical-or-expression ('?'! conditional-expression ':'! conditional-expression)?;

logical-or-expression = logical-and-expression ('||' logical-or-expression)*;
logical-and-expression = inclusive-or-expression ('&&' logical-and-expression)*;
inclusive-or-expression = exclusive-or-expression ('|' inclusive-or-expression)*;
exclusive-or-expression = and-expression ('^' exclusive-or-expression)*;
and-expression = equality-expression ('&' and-expression)*;

equality-expression = relational-expression (('==' | '!=') equality-expression)*;
relational-expression = shift-expression (('<' | '<=' | '>' | '>=') relational-expression)*;
shift-expression = additive-expression (('<<' | '>>') shift-expression)*;
additive-expression = multiplicative-expression (('+' | '-') additive-expression)*;
multiplicative-expression = cast-expression (('*' | '/' | '%') multiplicative-expression)*;

cast-expression = unary-expression | type-cast;
type-cast = '('! typedef-type ')'! cast-expression;

unary-expression = postfix-expression
| increment-decrement-expression
| unary-operator-expression
| sizeof-expression;

unary-operator-expression = unary-operator cast-expression;
increment-decrement-expression = (unary-increment | unary-decrement) unary-expression;

sizeof-expression = 'sizeof'! (unary-expression | typedef-type);

postfix-expression = postfix-increment-decrement | postfix-method-call | (primary-expression (array-access-expr
																				 | prop-access-expr
																				 | struct-access-expr)*);

postfix-increment-decrement = primary-expression (unary-increment | unary-decrement);
postfix-method-call = primary-expression method-call-expr;

array-access-expr = '['! expression ']'!;
method-call-expr = '('! expression? ')'!;
prop-access-expr = '.'! Identifier;
struct-access-expr = '->'! Identifier;


primary-expression = variable
| constant
| String
| '('! expression ')'!;

constant = integer-constant
| character-constant
| floating-constant
| boolean-constant
| enumeration-constant;

integer-constant = Int;
character-constant = String;
floating-constant = Float;
boolean-constant = Bool;
enumeration-constant = Identifier;

variable = Identifier;

expression = assignment-expression (','! expression)*;

assignment-expression = unary-expression assignment-operator assignment-expression | conditional-expression;

assignment-operator = ('*' | '/' | '%' | '+' | '-' | '<<' | '>>' | '&' | '^' | '|')? '='!;

unary-operator = '&' | '*' | '+' | '-' | '~' | '!';
unary-increment = '++';
unary-decrement = '--';


/* ***** Function definition ***** */

function-definition = type-specifier declarator function-body;
function-body = compound-statement;
