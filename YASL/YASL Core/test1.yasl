script test;

native void log(int x);

typedef enum {
	EventStateClear   = 0,
	EventStateSet     = 1,
	EventStateFailed  = 2,
	EventStateTimeout = 3,
} EventState;

native handle createEvent(char *identifier; int initialState; bool autoreset);
native handle signalEvent(handle event; int state);
native bool   closeEvent(handle event);

native int waitFor(handle event; int msec; int state);

typedef enum {
	ThreadStateNotReady   = 1 << 0,
	ThreadStateRunning    = 1 << 1,
	ThreadStateSleep      = 1 << 2,
	ThreadStateTerminated = 1 << 3,
} ThreadState;

native handle currentThread();
native handle threadStart(int threadMethod, threadState, parameter);
native bool   threadSuspend(handle thread; int msec);
native bool   threadResume(handle thread);
native bool   threadTerminate(handle thread; int returnCode);

int max(int a, b) {
	return a > b ? a : b;
}

int dummyThread(int *param) {
	handle self = currentThread();
	log(self);
	log(param);

	int event = (*param)[0];
	int sleepFor = (*param)[1];
	int delta = max(10, sleepFor / 10), i = 0;
	while (true) {
		threadSuspend(self, delta);
		log(self);
		log(i+=10);
		if (i > sleepFor) {
			signalEvent(event, EventStateSet);
			break;
		}
	}

	log(54321);
	return 1;
}

int main(int arg) {
	char eventName = 'a';
	handle event = createEvent(&eventName, EventStateClear, true);

	int params[] = {event, 12345};
	handle notifier = threadStart(&dummyThread, ThreadStateRunning, &params);

	int s = EventStateClear;
	while ((s = waitFor(event, 1000, EventStateSet)) == EventStateTimeout) {
		log(1000);
	}

	log(0);
	log(0);
	log(0);
	log(s);

	closeEvent(notifier);
	return 0;
}